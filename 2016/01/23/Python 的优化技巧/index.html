<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/" type="image/x-icon"><link rel="stylesheet" href="/stylesheet/brutalist.css"><title>Python 的优化技巧 · zypeh's blog</title><meta name="description" content="Python 的优化技巧 - zypeh's blog"><link rel="search" href="https://zypeh.github.io/atom.xml" type="application/opensearchdescription+xml" title="zypeh's blog"></head><body><div class="container"><script>window.onscroll = function() {scrollFunction()};
function scrollFunction(){if(document.body.scrollTop>320||document.documentElement.scrollTop>320){document.getElementById("gotoTop").className=""}else{document.getElementById("gotoTop").className="hidden"}}
function gotoTop(){document.body.scrollTop = 0;document.documentElement.scrollTop=0}</script><div class="wrapper"><div class="side-nav"><div class="side-nav-inner"><nav><ul><li><a href="/" target="_self">首页</a></li><li><a href="/archives" target="_self">归档</a></li><li><a href="/about" target="_self">关于</a></li></ul></nav><div class="divider-bold"></div></div></div><div class="spacing"><div class="spacing-inner"></div></div><main role="main"><div class="content"><header><div id="title"><h1>Python 的优化技巧</h1></div><div id="description"><p></p></div><div class="divider-curly"></div></header><article><p>上两个月，也就是 2015 年 11 月头的时候个人参与，并为一个高技术创业公司做架构设计。转眼间，在这我写这篇文章的时候已经过去两个半月了。写了不少的代码，也对优化有了大体的认识，因此在空余时间我就来扯淡扯淡。</p>
<p>首先我这几个月写的都是 Python 与 C 代码，而 Python 与 C 之间没有互相呼叫 (calling)，原因放在之后。所以我的用 Python 来做优化例子。</p>
<h2><span id="python实现">Python实现</span><a href="#python实现" class="linea">¶</a></h2>
<blockquote>
<p>&quot;Premature Optimization is the root of all evil&quot; —— Donald Knuth</p>
</blockquote>
<p>在谈 Python 的技巧前请让我说说 Python 实现的选择。个人选择 PyPy 实现是因为它所用的 JIT (Just-In-Time) 动态编译对 Python 代码而言提速很大。考虑 Numba 与 Pyston 的成熟度，PyPy 是支持度最高的一个 JIT 实现了，经过测试能和 Go 代码媲美。</p>
<blockquote>
<p>如果选择核心用其他语言代替 Python 内部实现的话，不考虑使用 JIT Python 实现。考虑到很多包没有对 C 扩展进行优化，这样做的话有可能跑下去比 CPython 还来的慢！</p>
</blockquote>
<p>解释器和编译器都会按照关键字来处理源码，所以了解编译器底层知识在这里扮演着很重要的角色。</p>
<h2><span id="善用-generator">善用 generator</span><a href="#善用-generator" class="linea">¶</a></h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pypy -mtimeit -n 100 <span class="string">"a = (i for i in range(10000))"</span></div><div class="line">100 loops, best of 3: 34.7 usec per loop</div><div class="line">$ pypy -mtimeit -n 100 <span class="string">"a = [i for i in range(10000)]"</span></div><div class="line">100 loops, best of 3: 0.441 usec per loop</div></pre></td></tr></table></figure>
<p>使用 '()' 的是 generator 对象，所需要的内存与列表无关，效率大了许多，但是遇到遍历 for loop 的时候</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pypy -mtimeit -n 10 <span class="string">"for x in [i for i in range(10000)]: pass"</span></div><div class="line">10 loops, best of 3: 203 usec per loop</div><div class="line">$ pypy -mtimeit -n 10 <span class="string">"for x in (i for i in range(10000)): pass"</span></div><div class="line">10 loops, best of 3: 277 usec per loop</div></pre></td></tr></table></figure>
<blockquote>
<p>在 Python 2.x 里面内置的 generator 为 xrange 和 itertools</p>
</blockquote>
<h2><span id="使用关键字会比函数高效">使用关键字会比函数高效</span><a href="#使用关键字会比函数高效" class="linea">¶</a></h2>
<p>有 ** 和 pow() 的对比：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pypy -mtimeit -n 10000 <span class="string">"c = 2**22"</span></div><div class="line">10000 loops, best of 3: 0.0473 usec per loop</div><div class="line">$ pypy -mtimeit -n 10000 <span class="string">"c = pow(2, 22)"</span></div><div class="line">10000 loops, best of 3: 0.185 usec per loop</div></pre></td></tr></table></figure>
<p>还有 if is ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ pypy -mtimeit -n 100 <span class="string">"a = range(10000); [i for i in a if i is True]"</span></div><div class="line">100 loops, best of 3: 32.3 usec per loop</div><div class="line">$ pypy -mtimeit -n 100 <span class="string">"a = range(10000); [i for i in a if i == True]"</span></div><div class="line">100 loops, best of 3: 36.9 usec per loop</div></pre></td></tr></table></figure>
<h2><span id="python-运行函数会比全局代码来的高效">Python 运行函数会比全局代码来的高效</span><a href="#python-运行函数会比全局代码来的高效" class="linea">¶</a></h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ pypy -mtimeit -n 10 \</div><div class="line"><span class="string">"</span></div><div class="line"><span class="string">def main():</span></div><div class="line"><span class="string">  a = range(10000); [i for i in a if i == True]</span></div><div class="line"><span class="string">main()</span></div><div class="line"><span class="string">"</span></div><div class="line">10 loops, best of 3: 86.8 usec per loop</div><div class="line">$ pypy -mtimeit -n 10 <span class="string">"a = range(10000); [i for i in a if i == True]"</span></div><div class="line">10 loops, best of 3: 87 usec per loop</div></pre></td></tr></table></figure>
<p>因为在函数中的代码块有着自己的局部作用域，有固定的矩阵大小 (因为考虑你无法动态增加变量进入函数里)，变量的名字存储成索引 (indexes)，从作用域外取得局部变量的流程就是用指针 (pointer) 指向这个列表跳转得到的。</p>
<p>反观全局代码要查询全局变量用的是 bytecode 的 <em>LOAD_GLOBAL</em>, 全局变量就是一个 dict() 结构。加上全局变量的查询是比局部变量查询来得耗时，函数会比全局代码快得多。</p>
<h2><span id="在循环里面缓存全局变量">在循环里面缓存全局变量</span><a href="#在循环里面缓存全局变量" class="linea">¶</a></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">g = range(<span class="number">10000</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(g)</span>:</span></div><div class="line">  p = g</div><div class="line">  <span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    [i <span class="keyword">for</span> i <span class="keyword">in</span> p <span class="keyword">if</span> i == <span class="keyword">True</span>]</div></pre></td></tr></table></figure>
<p>在循环里面要查询全局变量每次需要动用一次全局查询，不如在循环里面做一个缓存 <em>p</em>, 这样就会动用 bytecode 的 <em>STORE_FAST</em> 了。</p>
<blockquote>
<p>属性的查询是非常耗时的</p>
</blockquote>
<h4><span id="参考资料">参考资料</span><a href="#参考资料" class="linea">¶</a></h4>
<p><a href="http://pythonfasterway.cf/" target="_blank" rel="external">Python: Faster Way</a> - 这个有一系列的对比，可以得知差别
<a href="http://segmentfault.com/a/1190000000666603" target="_blank" rel="external">Python性能优化的20条建议</a>
<a href="http://stackoverflow.com/questions/11241523/why-does-python-code-run-faster-in-a-function" target="_blank" rel="external">Why does Python code runs fast in function</a></p>
</article></div></main><div class="corner_layer"><div class="corner_button"><button id="gotoTop" onclick="gotoTop()" class="hidden"><svg width="16" height="16" viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><title>回到顶部</title><g><path d="M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z" fill-rule="evenodd"></path></g></svg></button></div></div></div></div><footer><p>© 2017 - 2018 <a href="https://zypeh.github.io">zypeh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/zypeh/hexo-theme-brutalist" target="_blank">hexo-theme-brutalist</a>.</p><ul><li> <a href="https://zypeh.github.io">home</a></li><li><a href="/atom.xml">atom</a></li></ul></footer></body></html>