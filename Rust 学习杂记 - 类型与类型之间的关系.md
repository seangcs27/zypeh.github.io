title: 基本类型
date: 2016-10-20
---

## bool
布尔类型代表“*是*”， “*非*” 逻辑概念，只有两个值：**true** 和 **false**

```rust
let x = true; // x : bool
let y : bool = !x; // x 的倒义
```

## char
`char` 类型通 **character**, 单字符。我们用 `'` 来表示。
```rust
let x = 'x';
let moon = '🌚';
```
不像其他语言，Rust 语言的 `char` 类型其实不是占据单一 byte, 而是四个 bytes。因为要设计适配 Unicode 的任何字符。当然你能够通过 `\` 来转义
```rust
let next_line = '\n';
let literal_moon = '\ud83c\udf1a';
```

## 整数类型

Rust 的整数类型有很多，有占符号的，也有无符号，还有浮点数类型。以下就是列表

符号的意思就是这个值有没有符号位来表示这是正值还是负值，取决于最高的那个 bit 位。

大小             | 带符号  | 无符号    
:---------------:|:------:|:-------:
8 bit (1 byte)   | `i8`   | `u8`    
16 bit (2 bytes) | `i16`  | `u16`   
32 bit (4 bytes) | `i32`  | `u32`   
64 bit (8 bytes) | `i64`  | `u64`   
指针长短          | `isize`| `usize`

<div class="tip">
  取决于指针大小的 `isize` 和 `usize` 占据的大小是随着平台而各不相同的，如果你的平台是 32 bit 系统，那么就是 32 bit 大小，如果你的平台是 64 bit, 则是 64 bit。
</div>

浮点数有 `f32` 和 `f64`。直接写这样 Rust 也能够给你推导出来。

```rust
let float_num = 3.14159
```

整数类型可以有许多种方式表示：
```rust
let i1 : i32 = 0xC; // 十六进位制
let i2 : i32 = 12; // 十进位制
let i3 : i32 = 0o14; // 八进位制
let i4 : i32 = 0b1100; // 二进位制
```

所有的整数类型后面可以任意添加下划线，他会被省略的。这是用来方便阅读的。
```rust
let i5 = 12_000_000;
let i6 = 12_______000000; // 这样也可以
```

整数后面可以带类型，代表数字的类型。
```rust
let i7 = 0xffu8;
let i8 = 0xci8;
```

## 浮点数类型
Rust 语言用的是基于 [IEEE 754 标准](https://en.wikipedia.org/wiki/IEEE_floating_point)的浮点数表示。表示法就是：
除非明示，不然都是 64bit 浮点数来表示
```rust
let f1 = 3.    // f1 : f64
let f2 = 2E+33 // f2 : f64
let f3 = 2E+33f32 // f3 : f32
```

## 类型转换
Rust 是强类型编程语言，非常强调类型，两个类型之间如果要互相变换的话，Rust 语言提供两个方法，`as` 就是安全切换，切换动作会被 Rust 编译器严格监控，而 `transmute` 就是任意切换两个类型，是其中一个最危险的功能之一。

<div class="tip">
  不是说危险，而是 Rust 语言不会阻止程序员做自己想要做的事，只要该程序员知道自己在做什么……。所以不会对 `transmute` 做类型检查，直接切换，所以才说危险。) 这个我们之后会说。
</div>

数字之间的类型切换我们有很多规则：
```rust
let one = true as u8;
let two_hundred = -56i8 as u8;
```

1. 两个整数之间大小一样；**可以** (例如： `i32` -> `u32` 和 `u32` －> `i32` 都成立)

2. 把占内存空间大的整数类型转换到小的整数类型会被截短

3. 把占内存空间小的整数类型转换到大的整数类型会
 - 自动去掉符号位, 如果转换到的类型是无符号的 (例如 `i32` -> `u32`)
 - 自动在符号位填 0, 如果转换到的类型是有符号的 (例如 `u32` -> `i32`)

4. 浮点数 `f32` 转换到 `f64` 是不会有误差的。

5. 浮点数 `f64` 转换到 `f32` 会取近似值。

> 类型变换还会有一个情况, 叫 `Coercion`。这个我们会在后面细说。
