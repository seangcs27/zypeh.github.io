title:  21 世纪 C 语言指南 - 前言
date: 2016-10-18
---

C 语言如果是个人，那么他就是个 44 岁的巫师了。很老没错，但是我们的基本网络栈，作业系统和基本工具链都离不开它。直到现在 2016 年，还是很多人在写着 C 语言，在学着 C 语言，甚至在咒骂 C 语言的各种为定义行为。C 语言的种种设计也奠定了我们的编程语言的基本架构和语法，不停地被借鉴。

<!-- more -->
C 语言程序员是均衡分布在全球各地的。但是真正玩的溜 C 语言的程序员却很少见。因为 C 语言是个 **容易学习，难上手** 的编程语言。同时新手程序员很容易写出一些可以运行，但是有内存隐患的软件。所以 C 语言程序员很难有机会能够提升他们的能力。

C 语言是古老的语言，语言标准也随着年代和需求做出了妥协，改变了不少。现在的 C 语言已经大部分和它的设计者的初衷和目的不相同了。看看 1989 年的 C89, 1999 年的 C99, 还有 2011 年的 C11 标准就是 C 语言标准委员会订出来的。C 语言标准维护向后兼容 (同时也因为向后兼容吃了不少苦头，这个之后说)。因此这笔记当然会使用最新的标准来编写，使用的编译器是 Clang, LLVM。


## 其中一个误区： C++ 是 C 的扩展版？

这个命题如果放到过去是成立的。事实上，C++ 就是从 C 扩展出来的。但是那已经是 33 年前的事情了，C++ 和 C 有着很大的哲学差异，这庞大的差异都会体现在语法和实现上。在这期间双方都演变到截然不同的语言了。但是 C++ 在语法和类型系统上兼容 C 是对 C 程序员友好的，除了之后的异常处理，还有一些标准库都很大分别的。所以总结

> C++ 和 C 是全然不一样的东西，就像 Javascript 和 Java；热狗和狗的分别一样。

## 另一个误区： C 语言感觉很接近底层，是否因为这个造成速度快？

编程语言只负责描述一个程序，程序运行的速度很大程度不是取决于编程语言，取决于 **算法** 和 **编程语言实现** (也就是编译器或是翻译器，但我们不纠结这两个的分别)。编程语言的实现生成的代码质量差异才是速度的差异。因此接近底层的语言不一定速度快，因为目前编译器生成的代码已经很大部分可以与熟练的汇编程序员媲美了，有些时候甚至能够做到很多我们都做不到的底层优化。例如：寄存器分配，还有 stud 分配等等。

> 编程语言只是个描述程序的系统，它实现和描述的方法才是写出个好程序的关键

## 再来一个误区： C 语言是不是好选择？

C 语言在当时来说是个天才的设计 (在此致敬  Dennis Ritchie 和 Ken Thompson)。可以将汇编的语义映射到高等语言上，保持语言的简洁和概念上的简单。而且不阻止程序员做他们想做的事。但是到了现在我们与日俱增的复杂程度和准确性，C 语言的光芒就显得黯淡下来了。C 语言适合在:

1. 你需要可移植的汇编器
2. 你不会 C++
3. 和作业系统，底层打交道
4. 你想要学作业系统的相关知识

## 这份笔记……

这份笔记我尝试用严谨的学术风来写，而且会穿插各种例子来介绍。算是我对的 C 语言的学习做个总结。

读到这里，假如读者理解自己的需求，加上我写的还算好的话，你就大概会问 **C 语言的语法和如何开始写 C 语言?** 那么我会尝试在后面回答。

![C language - Chitanda](/images/21 世纪 C 语言指南 - 前言/image.jpg)
