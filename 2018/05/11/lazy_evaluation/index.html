<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/" type="image/x-icon"><link rel="stylesheet" href="/stylesheet/brutalist.css"><title>惰性求值和其特性一讲 · zypeh's blog</title><meta name="description" content="惰性求值和其特性一讲 - zypeh's blog"><link rel="search" href="https://zypeh.github.io/atom.xml" type="application/opensearchdescription+xml" title="zypeh's blog"></head><body><div class="container"><script>window.onscroll = function() {scrollFunction()};
function scrollFunction(){if(document.body.scrollTop>320||document.documentElement.scrollTop>320){document.getElementById("gotoTop").className=""}else{document.getElementById("gotoTop").className="hidden"}}
function gotoTop(){document.body.scrollTop = 0;document.documentElement.scrollTop=0}</script><div class="wrapper"><div class="side-nav"><div class="side-nav-inner"><nav><ul><li><a href="/" target="_self">首页</a></li><li><a href="/archives" target="_self">归档</a></li><li><a href="/about" target="_self">关于</a></li></ul></nav><div class="divider-bold"></div></div></div><div class="spacing"><div class="spacing-inner"></div></div><main role="main"><div class="content"><header><div id="title"><h1>惰性求值和其特性一讲</h1></div><div id="description"><p>惰性求值和其特性一讲</p></div><div class="divider-curly"></div></header><article><div class="index">
<!-- toc -->
<ul>
<li><a href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E4%BB%8B%E7%BB%8D">惰性求值介绍</a></li>
<li><a href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89">惰性求值的定义</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E6%B1%82%E5%80%BC%E7%9A%84%E8%BF%87%E7%A8%8B">延迟求值的过程</a>
<ul>
<li><a href="#whnf-weak-head-normal-form">WHNF (weak head normal form)</a></li>
</ul>
</li>
<li><a href="#equational-reasoning">Equational Reasoning</a></li>
</ul>
<!-- tocstop -->
</div>
<h1><span id="惰性求值介绍">惰性求值介绍</span><a href="#惰性求值介绍" class="linea">¶</a></h1>
<p>惰性求值被很多纯函数式采用来做求值策略，最典型的例子当然就是 Haskell 的 GHC 巨人。惰性求值应该分成两个特性来说：一个是延迟求值的过程；一个是做 Equational reasoning。</p>
<h1><span id="惰性求值的定义">惰性求值的定义</span><a href="#惰性求值的定义" class="linea">¶</a></h1>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">data</span> <span class="type">Lazy</span> : <span class="type">Type</span> -&gt; <span class="type">Type</span> where</span></div><div class="line">     <span class="type">Delay</span> : (val : a) -&gt; <span class="type">Lazy</span> a</div><div class="line"></div><div class="line"><span class="type">Force</span> : <span class="type">Lazy</span> a -&gt; a</div><div class="line"><span class="type">Force</span> (<span class="type">Delay</span> x) = x</div></pre></td></tr></table></figure>
<p>以上是 Idris 的一段代码用来表示惰性求值的定义。</p>
<ul>
<li><code>Delay</code> 类型包裹 <code>val</code> 然后返回 <code>Lazy</code> 类型</li>
<li><code>Force</code> 函数接受包裹了 <code>Lazy</code> 类型的 <code>val</code> 返回 <code>val</code></li>
</ul>
<blockquote>
<p>在 Chris Okasaki 的 《Purely Functional Data Structures》一书里面就用了严格求值的 SML 编程语言，然后在里面模拟了一个惰性求值的语法，<strong>$-notaion</strong> 。这样 <code>$expression</code> 就和 <code>(Delay expression)</code> 等义。</p>
</blockquote>
<p>在 Idris 编程语言，<code>Force</code> 和 <code>Delay</code> 是自动插入的，大部分时候我们并不用关心语法问题，也不需要明示 <code>Force</code> 和 <code>Delay</code>。</p>
<p>可是 <code>Delay</code> 和 <code>Force</code> 究竟能够怎样怎样组成惰性求值呢？</p>
<h1><span id="延迟求值的过程">延迟求值的过程</span><a href="#延迟求值的过程" class="linea">¶</a></h1>
<p>大多数编程语言采用的策略是严格求值，（strict evaluation 或是 eager evaluation）。在求值一个函数的结果之前，参数需要先求值成为一个值，而不是一个表达式 (expression)。比如说这个：</p>
<figure class="notes">
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">head</span> [<span class="number">1</span>+<span class="number">2</span>, <span class="number">3</span>*<span class="number">4</span>]</div><div class="line"><span class="title">head</span> [<span class="number">3</span>, <span class="number">12</span>]</div><div class="line"><span class="number">3</span> <span class="comment">-- result is 3, the first element of the list</span></div></pre></td></tr></table></figure>
<figcaption>head 接受一个列表，返回列表首个元素。</figcaption>
</figure>
<p>而惰性求值并不是这样，它希望求值一个表达式越晚越好，直到需要到这个值的时候才开始执行求值的过程。在这个例子中，惰性求值策略不会确定列表元素的值，而是直接调用 <code>head</code> 得到一个尚未被求值的列表元素 <em>(3+2)</em>。</p>
<p>直到我们需要这个值：比如说需要打印这个结果，<em>(3+2)</em> 这个元素需要被求值，才会执行这个过程。</p>
<p>这种求值方式也被称为按需求值 （<strong>Call by need</strong>）。</p>
<h2><span id="whnf-weak-head-normal-form">WHNF (weak head normal form)</span><a href="#whnf-weak-head-normal-form" class="linea">¶</a></h2>
<p>求值一个表达式越晚越好并不是简单的事情。因为不知道什么时候去求值的话会导致无限递归。在求值的过程中，Haskell 的编译器 (这里我们都说是 GHC) GHC 求值只会求值到该表达式的 WHNF (weak head normal form)，最外层的值构造器 (<strong>Constructor</strong>) 或是另一个函数。我们把这个叫一个代码块为 <strong>thunk</strong>。</p>
<figure class="notes">
<img src="whnf.jpg">
<figcaption>一个列表可以看成是一个 thunk</figcaption>
</figure>
<blockquote>
<p>在 GHC 里面，thunk 是很轻量的。而且是能够被共享，也就是说这个 thunk 其实能够被相同的表达式所用，因为纯函数在输入相同的前提下，结果必定相同。一个相同的表达式其实可以用指针指向同一个 thunk 来避免多余的计算。这个过程叫记忆化 (<strong>memoization</strong>)</p>
</blockquote>
<h1><span id="equational-reasoning">Equational Reasoning</span><a href="#equational-reasoning" class="linea">¶</a></h1>
<hr>
<p><em>待续</em></p>
<hr>
<h4><span id="参考资料">参考资料</span><a href="#参考资料" class="linea">¶</a></h4>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/34201756" target="_blank" rel="external">柯里化的前生今世（十三）：Weak head normal form</a> 惰性求值例子抄袭自这里</li>
<li><a href="https://wiki.haskell.org/Thunk" target="_blank" rel="external">Thunk 的相关资料</a></li>
</ul>
</article></div></main><div class="corner_layer"><div class="corner_button"><button id="gotoTop" onclick="gotoTop()" class="hidden"><svg width="16" height="16" viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><title>回到顶部</title><g><path d="M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z" fill-rule="evenodd"></path></g></svg></button></div></div></div></div><footer><p>© 2017 - 2018 <a href="https://zypeh.github.io">zypeh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/zypeh/hexo-theme-brutalist" target="_blank">hexo-theme-brutalist</a>.</p><ul><li> <a href="https://zypeh.github.io">home</a></li><li><a href="/atom.xml">atom</a></li></ul></footer></body></html>