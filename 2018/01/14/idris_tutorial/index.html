<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/" type="image/x-icon"><link rel="stylesheet" href="/stylesheet/brutalist.css"><title>Idris 初学手札 · Hexo</title><meta name="description" content="Idris 初学手札 - Hexo"><link rel="search" href="http://yoursite.com/atom.xml" type="application/opensearchdescription+xml" title="Hexo"></head><body><div class="container"><script>window.onscroll = function() {scrollFunction()};
function scrollFunction(){if(document.body.scrollTop>320||document.documentElement.scrollTop>320){document.getElementById("gotoTop").className=""}else{document.getElementById("gotoTop").className="hidden"}}
function gotoTop(){document.body.scrollTop = 0;document.documentElement.scrollTop=0}</script><div class="wrapper"><div class="side-nav"><div class="side-nav-inner"><nav><ul><li><a href="/" target="_self">首页</a></li><li><a href="/archives" target="_self">归档</a></li><li><a href="/about" target="_self">关于</a></li></ul></nav><div class="divider-bold"></div></div></div><div class="spacing"><div class="spacing-inner"></div></div><main role="main"><div class="content"><header><div id="title"><h1>Idris 初学手札</h1></div><div id="description"><p>大概介绍所谓的 Idris 编程语言的特点，还有所学到的东西，做个总结。</p></div><div class="divider-curly"></div></header><article><div class="index">
<!-- toc -->
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-idris">什么是 Idris</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-idris">为什么选择 Idris ?</a></li>
</ul>
</li>
<li><a href="#idris-%E7%9A%84%E7%89%B9%E7%82%B9">Idris 的特点</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D">语法介绍</a>
<ul>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89">声明和定义</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D">模式匹配</a></li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%95%B0%E7%BB%84">模式匹配和数组</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
</div>
<h1><span id="什么是-idris">什么是 Idris</span><a href="#什么是-idris" class="linea">¶</a></h1>
<p>Idris 是一个由 Edwin Brady 设计的编程语言。是个纯函数式 (Purely Functional Programming) 和依赖类型 (Dependent Type) 的混合体，默认严格求值，有着可选的惰性求值类型，自带程序验证功能 (Totality Checker) 让这个编程语言更适合在工程上体验依赖类型。</p>
<h2><span id="为什么选择-idris">为什么选择 Idris ?</span><a href="#为什么选择-idris" class="linea">¶</a></h2>
<ul>
<li>Idris 有着各种后端 codegen，有 JVM, CIL, Ocaml 和部分支持 LLVM</li>
<li>Idris 能够编译成 Javascript 和带垃圾回收机制 (Garbage Collection) 的 C 程序</li>
<li>Idris 提供很好的 FFI 接口 (Foreign Function Interface)，还有 Effect system 来处理状态，这个特点允许在嵌入式平台上探索函数式编程的实用性</li>
<li>Idris 的语法和 Haskell 很接近，甚至少了很多语法坑</li>
<li>Idris 还很新，年轻力盛的少年可以考虑献祭下</li>
</ul>
<h1><span id="idris-的特点">Idris 的特点</span><a href="#idris-的特点" class="linea">¶</a></h1>
<p><strong>Dependent Type</strong>，<strong>自带证明器</strong> 就是它的杀手锏。依赖类型把语言实现简约了，比起 HM 类型系统，强调区分 Kinds, Functions, Variables, Type 和 Typeclasses。它实际上把类型变成了第一公民，而值能够出现在类型上。</p>
<hr>
<p>从官方文档拿出个例子，我们能够写个函数去计算一个类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">isSingleton</span> : <span class="type">Bool</span> -&gt; <span class="type">Type</span></div><div class="line"><span class="title">isSingleton</span> <span class="type">True</span>  = <span class="type">Nat</span></div><div class="line"><span class="title">isSingleton</span> <span class="type">False</span> = <span class="type">List</span> <span class="type">Nat</span></div></pre></td></tr></table></figure>
<p>或者可以用这个函数来计算一个类型，反正这个函数返回的是一个类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">mkSingle</span> : (x : <span class="type">Bool</span>) -&gt; isSingleton x</div><div class="line"><span class="title">mkSingle</span> <span class="type">True</span>  = <span class="number">0</span></div><div class="line"><span class="title">mkSingle</span> <span class="type">False</span> = []</div></pre></td></tr></table></figure>
<p>然后还能够检查参数类型，通过传递这个函数来计算，返回类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">sum</span> : (single : <span class="type">Bool</span>) -&gt; isSingleton single -&gt; <span class="type">Nat</span></div><div class="line"><span class="title">sum</span> <span class="type">True</span> x = x</div><div class="line"><span class="title">sum</span> <span class="type">False</span> [] = <span class="number">0</span></div><div class="line"><span class="title">sum</span> <span class="type">False</span> (x :: xs) = x + sum <span class="type">False</span> xs</div></pre></td></tr></table></figure>
<hr>
<h1><span id="语法介绍">语法介绍</span><a href="#语法介绍" class="linea">¶</a></h1>
<p>不赘述，以下是 Idris 的 Hello World 程序。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> Main</div><div class="line">main : IO ()</div><div class="line">main = putStrLn "Hello World!"</div></pre></td></tr></table></figure>
<p>然后我们编译上面的代码，<code>hello.idr</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ idris hello.idr -o hello</div><div class="line">$ ./hello</div><div class="line">Hello World!</div></pre></td></tr></table></figure>
<h3><span id="声明和定义">声明和定义</span><a href="#声明和定义" class="linea">¶</a></h3>
<p>Idris 用的是和 Haskell 的一套。靠模式匹配做数据之间的映射。类型的声明靠 <code>:</code> 来表示，后面跟着的是类型。而 <code>=</code> 用来定义返回的值。就像这样:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">branchingFactor</span> : <span class="type">Int</span></div><div class="line"><span class="title">branchingFactor</span> = <span class="number">32</span></div></pre></td></tr></table></figure>
<h3><span id="函数">函数</span><a href="#函数" class="linea">¶</a></h3>
<p>函数也是同样的方式来定义。 <code>--</code> 后面接着的是注释，而 Idris 是没有块注释的。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">isOdd</span> : <span class="type">Int</span> -&gt; <span class="type">Bool</span> <span class="comment">-- 定义 isOdd 函数接受 Int 返回 Bool 类型</span></div><div class="line"><span class="title">isOdd</span> x = (mod x <span class="number">2</span>) == <span class="number">1</span></div></pre></td></tr></table></figure>
<h3><span id="模式匹配">模式匹配</span><a href="#模式匹配" class="linea">¶</a></h3>
<p>而模式匹配能够匹配不同条件，比如说下面的代码。<code>isSingleton</code> 根据接受的 <code>Bool</code> 类型参数来决定返回的类型 (Type)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">isSingleton</span> : <span class="type">Bool</span> -&gt; <span class="type">Type</span></div><div class="line"><span class="title">isSingleton</span> <span class="type">True</span> = <span class="type">Nat</span></div><div class="line"><span class="title">isSingleton</span> <span class="type">False</span> = <span class="type">List</span> <span class="type">Nat</span></div></pre></td></tr></table></figure>
<h3><span id="模式匹配和数组">模式匹配和数组</span><a href="#模式匹配和数组" class="linea">¶</a></h3>
<p>模式匹配是个很强的语言特性，事实上，它能够让我们更方便地书写条件。比如说模式匹配列表就是一个很好的例子。</p>
<hr>
<p>举个例子：</p>
<p>列表 (List) 就是一个优化连接的数据结构。写成</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">-- 1 :: 2 :: 3 :: 4 :: Nil</span></div></pre></td></tr></table></figure>
<p>同时 <code>Nil</code> 也可以表示 <code>[]</code></p>
<p>所以当我们模式匹配的时候。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">isNil</span> : <span class="type">List</span> a -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">isNil</span> []      = <span class="type">True</span></div><div class="line"><span class="title">isNil</span> (x::xs) = <span class="type">False</span></div></pre></td></tr></table></figure>
<figure>
<img src="pattern_matching.png">
<figcaption>模式匹配的 xs 就是多个 x 的意思。也就是说除了从第二个元素开始的链表</figcaption>
</figure>
<p>最后一行的 <code>(x::xs)</code> 其实就是取列表的首元素和接下来的元素列表。</p>
<hr>
<p><em>待续</em></p>
<hr>
</article></div></main><div class="corner_layer"><div class="corner_button"><button id="gotoTop" onclick="gotoTop()" class="hidden"><svg width="16" height="16" viewBox="0 0 17 17" xmlns="http://www.w3.org/2000/svg"><title>回到顶部</title><g><path d="M12.036 15.59c0 .55-.453.995-.997.995H5.032c-.55 0-.997-.445-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29c.39-.39 1.026-.385 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z" fill-rule="evenodd"></path></g></svg></button></div></div></div></div><footer><p>© 2017 - 2018 <a href="http://yoursite.com">zypeh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/zypeh/hexo-theme-brutalist" target="_blank">hexo-theme-brutalist</a>.</p><ul><li> <a href="http://yoursite.com">home</a></li><li><a href="/atom.xml">atom</a></li></ul></footer></body></html>