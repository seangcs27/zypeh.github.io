title: Rust 学习杂记 - 语法与语义
date: 2016-10-20
---

Rust 语言的语法很大程度是从 Ocaml 借鉴过来，而不是我们常见的 C 家族语法。在这里我会介绍：变量，函数还有很多还未接触过的 Rust 概念。但是不用担心这些细节，只要专注在程序的表达和特性就行了。

<!-- more -->

Rust 主要都是表达式语言，主要有两个类型: **声明语句** 和 **表达式语句**, 除了声明语句只有两个情况，除此之外全都语句都是是表达式。

表达式之间能够互相嵌套，组成一个强大的功能，同时也能提供强大的表达能力。

## 注释

代码是想法的实现，程序运行的描述。注释就是在你的源程序代码留下笔记，方便其他的程序员 ( 或是日后的你自己！ )。注释不会被编译器处理。所以写好它来给程序员阅读。

Rust 有两种注释，一个是行注释 `//`, 一个是文档注释, 用 `///` 表示。

文档注释就是用来给包管理器 **cargo** 生成文档用的。
```rust
/// # 这是文档注释
///
/// ## 你绝对想不到能够用 markdown 来写文档
/// 文档里面可以和源码做上下文检查的
// 例如
/// A convenience typedef around a `Future` whose error component is `io::Error`
pub type IoFuture<T> = BoxFuture<T, io::Error>;
```

> 还有一种是用在库里面的，例如 modules 和 crates 用的，用 `//!` 表示。
```rust
//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
```

文档能够用 `cargo` 这类型的包管理系统来生成一个文档网页。你可以到 Rust 文档集中区 [doc.rs](https://docs.rs) 去看看。

![scopes](/images/Rust 学习杂记 - 语法与语义/documentation.png)

## 变量

变量要先声明才能调用，但是 Rust 语言我们说变量是绑定 (*binding*)。我们用 `let` 关键词来绑定变量和值。

>绑定 (*binding*) 和 赋值 (*assignment*) 的分别?

> **绑定比赋值有更大的意义。** 绑定将某个 item 赋予一个名字。而赋值就是纯粹存储某个值或是 **某个位址**。在数学上我们都称呼他们为变量，但是在电脑科学我们会区分这是内存位址还是变量的值本身。变量本身就能视为一个存储值的内存空间，赋值就是将内存空间里面的值修改掉，例如你之前赋值了 `foo`, 第二次赋值你就把 `foo` 替换成新值了。而绑定就是将这个值打标签，不会对值任何的修改。这个我们后面会说到。

```rust
let a = 7;
let b = 8;
```

## 可变变量

Rust 语言默认变量就是不可变的。你不能通过表达式来修改变量。就如下面的例子那样，
```rust
let a = 7;
let b = 8;
a = 6;
b = 7;
```
编译器会报错，因为你在第三，四行修改了变量的值。我们需要在 `let` 关键词的后面加上 `mut`。通 **mutable** 之意。标示这是个可变的变量。
```rust
let mut a = 7;
let mut b = 8;
a = 6;
b = 7;
```

> Rust 强调安全的同时，也做出了很 “一致性” 的设计。在这里我们应该把 `mut` 和变量看成是一个组合，而不是 `let mut`, 因为 `let` 这关键字不止负责捆绑变量。`let` 其实还是个模式构造器。这个我们后面会开始提到

## 类型表示

Rust 是静态语言，值都有个类型，而且是在编译期的时候就被编译器决定好了，不在运行时去检查值的类型。我们之前的例子其实是整数类型 `i32`。

```rust
let a : i32 = 7;
let b : i32 = 8;
```

变量声明一定是用 `let` 开头，类型在 `:` 的后面。

>Rust 类型后置，中间加上了 `:` 不无理由。这个我们会在后面细说。除此之外 `Go` 语言也是类型后置，但是少了 `:` 类型符号。这个我也会在后面吐槽。

>为什么上面的例子没有用 `: i32` 标示类型而能够编译成功？因为 Rust 用了 **类型推导**。Rust 编译器会自动推导类型，所以大部分情况不用写类型都行，除非你要明示某个类型才用。

## 函数

每个 Rust 程序都至少有一个函数，那就是 `main` 函数。
```rust
fn main() {

}
```
`fn` 通 **function** 之意。而 `fn` 接下来的一定是这样的语句。
```rust
fn foobar() {

}
```
这是一个函数名叫 `foobar`, 括号表示函数所接受的参数，花括号表示他的语句块。这我之后会花很大的幅度去讨论。
括号里面没有任何内容，说明这个函数没有接受任何参数。

有接受参数的函数是怎样的呢？我们看看下边这个
```rust
fn print_number (x : i32) {
  println!("x is {}", x);
}
```
这个函数会打印号码他所接受的参数也就是一个 `i32` 类型的整数。
语句块里面的 `println!` 是打印的函数。

而函数要回馈一个值的时候用 `->` 箭头表示，如下:
```rust
fn incremental (x: i32) -> i32 {
  x + 1 // 这里没有加分号
}
```

这就是取参数 `整数类型的 x` 然后返回 `整数类型的 x+1`，中间值得一提的是里面的内容，我在后面会说到。

## 变量的初始化和作用域
函数都有他们自己的语句块 `{` `}`。而这个语句块就是这个函数的作用域，我们其实称它为 **scope**。在这时候我们回到我们的变量的部分。

```rust
fn main() {
  let a = 7;
  let b = 8;
}
```

其实我们对一个新变量 `let` 绑定是需要被初始化的。所以 **捆绑** 和 **初始化** 其实要合在一起说。

对于 `let a = 7;` 我们是 **先初始化一个值才能够绑定该值**。这个例子和上面的例子等义。
```rust
fn main() {
  let a; a = 7;
  let b; b = 8;
}
```

如果一个变量被初始化了但是却没有被利用，例如没有被用来计算 ( 或是准确地说：*被引用* ), Rust 编译器就会提出警告。
```rust
fn main() {
  let a : i32;
}
```
提出警告:
```text
warning: unused variable: `a`, #[warn(unused_variables)] on by default
 --> <anon>:2:7
  |
2 |   let a : i32;
  |       ^
```
这说明了我们有个没有被用到的变量。这变量被初始化了却没有被引用，但是这是合法的，所以 Rust 编译器没有报错，但是这是不利于工程的，所以 Rust 会很贴心地提出警告。

> 没有被用到的变量其实会被编译器做优化程序，死代码扫除 [(dead code elimination)](https://en.wikipedia.org/wiki/Dead_code_elimination) 的时候被去掉。对生成的二进制程序没有多大的影响，但是没用的变量很影响代码的阅读性。

<div class="tip">永远不要忽视现代编译器的任何警告。</div>

我们来弄个试验, 我们尝试使用这个变量。
```rust
fn main() {
  let x : i32;
  println!("{}", x);
}
```
在这里我们打印一个已经绑定了的值。但是现在编译器报错了。
```text
error[E0381]: use of possibly uninitialized variable: `x`
 --> <anon>:3:18
  |
3 |   println!("{}", x);
  |                  ^ use of possibly uninitialized `x`
```
这说明了我们不能使用一个没有初始值的变量，尽管它已经被绑定了命名。

## 作用域 (scope)
变量的值是绑定了的，会随着作用域影响。举个例子：
```rust
fn foo(x: i32) {
  let y = 3; // 绑定 y 为 3
  println!("[inner] x is {}, y is {}", x, y); // 打印 x 和 y
}

fn main() {
  let x = 2;
  foo(x);
  println!("[outer] x is {}, y is {}", x, y); // 打印 x 和 y
}
```
我们在 `foo` 函数里面初始化了 `y` 变量为 3。然后在 `main` 函数里面调用。在 `foo` 和 `main` 里面打印 x 和 y。结果编译器报错了。
```text
error[E0425]: unresolved name `y`. Did you mean `x`?
 --> <anon>:9:43
  |
9 |   println!("[outer] x is {}, y is {}", x, y); // 打印 x 和 y
  |                                   ^
```
这时候在最外层的 `y` 不能被解析，这是因为 `y` 的值在 `foo` 的作用域之下。出了作用域，`y` 这个值的绑定就会被回收掉。

![scopes](/images/Rust 学习杂记 - 语法与语义/scopes.png)

绑定如果在同一个作用域，那就会有重复绑定 (`shadowing`) 的情况出现。
```rust
fn main() {
  let x = 7;
  let x = 8;
  println!("{}", x); // 打印 8
}
```
这时候就会打印一个 **8**。这不是赋值，这是重复绑定。而同时编译器也会提出警告。
>第一个 `x` 和第二个 `x` 是两个不同的变量，只是名字一样而已。第一个 `x` 和第二个 `x` 都在内存占据着空间。而重复绑定同一个名字，其实大有用途。这个后面细说。

> 编译器的警告证明了第一个 `x` 其实被初始化了但是没有被使用到。
```text
warning: unused variable: `x`, #[warn(unused_variables)] on by default
 --> <anon>:2:7
  |
2 |   let x = 7;
  |       ^
```

然而我们其实也能自己显式地手动建一个作用域。通过 `{` `}`。
```rust
fn main() {
  let x = 2;
  { // 一个作用域
    let y = 3;
    println!("[inner] x is {}, y is {}", x, y); // 打印 x 和 y
  }
  println!("[outer] x is {}, y is {}", x, y); // 打印 x 和 y
}
```

## 声明语句和其他表达式的差别
声明语句和其他表达式的最大分别是 **回馈的值**。举个例子：
```rust
let x = y = 7;
```
那么这个时候我们的 `let` 会把这个看成是一个绑定，而不是表达式。而是这样：
```rust
let x = (let y = 7);
```
所以我们得到 `y` 等于 7, 而 `x` 等于 `()`。这就是一个很大的分别, 同时我们可以看到，其实如果一个函数没有回馈任何的值，我们也是这样回馈，有没有写返回类型都一样：
```rust
fn print_number (x:i32) -> () { // 多了返回类型, 返回 `()`
  println!("{}", x);
}
```
> 上面那个和下面那个等义
```rust
fn print_number (x:i32) { // 少了返回类型，返回 `()`
  println!("{}", x);
}
```

同理，我们也能够通过语句块表达式用 `let` 来绑定。这时候的 `x` 也是 `()` 类型
```rust
let x = { println!("this is an x"); }
```

而回到这里：
```rust
fn incremental (x: i32) -> i32 {
  x + 1 // 这里没有加分号
}
```
Rust 受到 Ocaml 的影响，如果一个语句块没有 分号 `;`。那么就是返回的值，而这个值本身也可能是个语句。如果我们在第二行 `x + 1` 的行尾加了个 `;`，编译器就会报错。因为加了 `;` 那就是表达式了。返回的结果就是 `()`，和函数所要返回的类型 `i32` 不一样。所以不成立，报错。
```rust
fn incremental (x: i32) -> i32 {
  x = 1;
}
```
```text
error[E0269]: not all control paths return a value
 --> <anon>:1:1
  |
1 | fn incremental (x: i32) -> i32 {
  | ^
```

这就是表示 Rus 语言将 `;` 定义为语句的结尾，而不是区分语句的符号。一个语句的结束伴随着 `;`。后期会说更多。如果你要在函数里面返回一个表达式的值。你可以选择用 `return`。
```rust
fn incremental (x: i32) -> i32 {
  return x + 1;
}
```

> 没有 `return` 的语句看起来固然陌生没错，但是如果你理解了 Rust 语言 **基于表达式** 的设计，你就不难理解为何他要这样设计了。

Rust 的表达式设计带来了很强大的一致性，同时也有很特别的思想。程序员应该了解的是值和类型本身，而不是变量的命名，如果一个变量没有绑定一个值，那就不成立了。而且表达式语句块都能够返回值，可以用来给编译器检查。得到很高的抽象能力同时也得到了很强的错误处理机制。
