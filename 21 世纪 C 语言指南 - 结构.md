---
title:  21 世纪 C 语言指南 - 结构
date: 2016-10-24
---

C 语言的语法和结构很简单，但是背后的设计却不是如此。在这里我会用最短的篇幅来解释 C 语言的语法层面，尽量把 C 语言简洁的一面带出来，没有黑魔法和难懂的条约，我保证。 :-)

<!--more-->

# C 语言的设计
C 语言首先就是设计出来取代汇编成为一个**接近底层的高等语言**。首先，

- C 语言是编译型编程语言

C 语言代码不能单独被运行，首先它要*被翻译成电脑所能了解的语言。*也就是，**二进制代码** (binary-code) 或是**目标代码** (target code) 俗称，**可运行包** (executable)。而把我们的 C 代码翻译到二进制的就是**编译器** (compiler)。

> 编译器其实是一系列程序的组合。编译过程中其实还有各种优化措施和静态链接动作。这个需要花很大篇幅去解说呢。

而编译得到二进制代码必定是根据当前的主机平台做足充分优化，把目标代码放到其他的平台就不一定能运行。因为我们说编译器生成的 **目标代码**，是平台依赖 (platform dependent) 的。

- C 代码是可以移植到各个平台的

前提是我们需要找个支持该平台的 C 语言编译器。因为我们知道，把 C 代码翻译成电脑所能了解的二进制代码是编译器的工作。通过编译器，C 语言代码才能在各个平台上运行。所以 C 语言的编译器在这里扮演很重要的角色。

- C 语言和其他的编程语言一样，都有自己的一套语言标准。
*(只不过 C 语言的比较特殊，因为种种的原因，C 语言经历过一段混乱时期)*

> 如果你是 90 后的高中生，而且有 1Mbps 以上的网速，4 GB 以上的内存。看着这篇文章，迫不及待地想要学 C 语言。那么你是幸运的。

早期的 C 语言标准不一 (而那时候也是 C 语言的狂潮，准确来说是 80 年代初，Microsoft 还有自己的编程语言，叫 **BASIC**)，各个厂商如 IBM, SUN, Microsoft 都尝试制定自己的关键字。还有，各个编译器的实现都不一样，确实有点神秘。

> 早期的 ANSI C 标准表示在 C 语言使用 `#pragma` 表示符能够向编译器提示信息。由于这个不是 C 语言最初的设计 (`pragma` 是从 **Ada 编程语言**来的)， ANSI C 也没有对这个表示符做进一步的规定，而是把决定权交给编译器决定。如此的举动遭到 gcc 编译器开发者反对，所以把这个表示符弄得更奇葩一点。

> 在 GCC 1.34 版本中，如果使用了 `#pragma` 表示符，就会尝试运行 "rogue" 游戏；如果失败，尝试运行 "hack" 游戏；如果失败，它就会打开 Emacs 编辑器，显示 Tower of Hanoi。如果还是失败，就打印错误。停止编译下去。
> ![Emacs Hanoi-mode](/images/21 世纪 C 语言指南 - 结构/hanoi_emacs.png)

现在的 C 语言标准已经很完善了(噢！我指的是越来越容易理解)，规定总结编译器的行为：

- C 语言编译器只有在违反语法规则和约束条件的情况下才会报错。其他情况，如警告都不会阻止你的代码编译过程。

<div class="tip">
  绝对不要忽略任何一个编译器提出的警告，**绝对**!
</div>

<div class="tip">
  标准表示**编译器只有在违反语法规则和约束条件的情况下才会报错**, 那么如果我编写合法，但是不属于任何一个约束条件的代码呢？
  这时候你的代码能够顺利被编译，但是这种行为属于 "**未定义行为**" (**undefined behavior**, 简写 **UB**), 编译器可以采取任何行动，而你完全不知情。
</div>

运行时检查与 C 语言的设计理念相违背。**按照 C 语言的理念，程序员应该知道自己正在干什么，而且保证自己的所作所为是正确的。**

# C 语言的主要结构

## 语法
我们的语法规矩也很简单，主要是有一下几种基本元素：

- **关键字** (**keyword**)，也可以说是**保留关键字** (**reserved keyword**), 例如 `int`, `return`, `#define`, `#include`。

- **符号**，我们有 `(...)`, `{...}`, `[...]` 和 `/* ... */`, 都是用来标示语句块。
然后我们有 `,` 用来区分函数参数的划分，`;` 用来结束表达式。

- **常量表达式** (**literal expression**), 这些都是值的表示。有可能是字符串，或是整数，浮点数。
例如: `0`, `1`, `2`, `0.3`, `2.3E+19` 或是 `"abc"`

- **标示** (**identifier**)，标示根据上下文而扮演不一样的角色。
它可以是：
  - 变量名
  - 函数名
  - 自定义的类型名
  - 常量 
<div class="tip">
  任何标示名的中间不能包含操作符 `+`, `-`, `/`, 或是在函数名中使用 `*`, `&`。但是 `_` 是合法的，你能够在函数名中使用。
</div>

- **操作符** (**operator**), 如 `++`, `+=`, `>` 和 `=` 等。 

- **函数** (**function**), 函数一定是伴随着 `()` 指明接受的参数，紧接着 `{}` 语句块来表示函数的内容。我们会把函数 `{}` 的语句块视作这个函数的定义。然后函数名前面的**标示**表示这个函数返回的值的类型。

## 定义与声明
前面说了**标示**是上下文依赖的，怎么说呢？

- 标示和关键字的功能相似，分别在于，**标示需要声明才能使用**。而**关键字的定义是老早就在 C 语言标准里定义好了。**

> 这就是为什么我们说标示名不能使用保留关键字，或是内含操作符。因为编译器无法解析你的声明式究竟是在使用关键字还是声明一个标示。进而报错结束编译过程，编译器不会生成任何二进制代码。

```c
int i = 100;
```
以上这个代码就是用关键词 `int` 来定义一个变量**i**, 然后用 `=` 操作符来定义这个变量。所以我们把要定义的内容，**100** 放在右边，我们称之为**右值**。把 **i 定义为 100**。

而函数其实也能当作标示来使用。所以当我们使用的时候我们需要一个 `()` 括号来表示它接受的参数。
```c
printf("%d", 100);
```
所以我们就是在打印一个整数 **100** 在荧幕上。在这里 `printf` 是个函数。接受两个参数，也就是 `"%d"` 和 `100`，之间用逗号`,`分开。而**函数的定义就是这个函数要做的东西。**

标示和函数的定义我们之后会继续说。但首先我们来实战看看 C 语言程序的源码。

# 程序的结构 
C 语言程序由函数和变量组成，而函数里面包含表达式，描述我们程序要做什么，以及要如何做。 **变量** 存储我们运算过程中或是运算过程后所得到的值。而 **函数** 则是用来划分我们的程序，简化描述的过程。

首先就来个打印时间的库开始看起。而不是我们的常见的 Hello world.

```c
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
  
// 这是多元数组
char *weekday[7] = {
  [0] = "Sunday",
  [1] = "Monday",
  [2] = "Tuesday",
  [3] = "Wednesday",
  [4] = "Thursday",
  [5] = "Friday",
  [6] = "Saturday"
};
  
/* 这是程序入口 */
int main() {
  /* initiation */
  struct tm current_time, *time_pointer;
  int second, minute, hour, wday;
  char *time_indicator = NULL;
  long int s;
  
  s = time(NULL);
  time_pointer = &current_time;
  localtime_r(&s, time_pointer);
  
  /* Pointer magic */
  hour = current_time.tm_hour;
  
  if (hour > 12) {
    time_indicator = "PM";
  } else {
    time_indicator = "AM";
  }
  
  minute = time_pointer->tm_min;
  second = *((int *) time_pointer);
  wday = (*(time_pointer)).tm_wday;
  
  printf("%s %d:%d:%d %s\n", time_indicator, hour, minute, second, weekday[wday]);

  return EXIT_SUCCESS;
}
```
这个会在荧幕上打印：
```text
18:21:19 Saturday
```

经过编译，这个源码终将成为电脑能够读取，并运行的程序。
我们一行一行来解释，但首先我们来解析这个程序的结构，从源码看起。

## 库的使用

看到第一和第二行的 `#include` 吗？`#include` 告知编译器将这个库的源码包含到我们这个源码里。库简化我们的开发开销，也就是说这些库都是前人写过的源码，然后放到电脑的某个路径，给编译器加载，完成某些工作。

在这里我们使用了 `stdio.h` 和 `time.h` 这两个库。前者是负责和字符打印的工作有关，后者是时钟系统有关的库。

>如果你尝试去掉首两行的，不适用外来的库。那么你的程序很大可能性不能被执行。因为在这里我使用上 `printf()`，`time()` 和 `localtime_r()` 函数了，而这三个函数我都不在源码里定义。那么这三个函数的定义在哪里呢？

>答案在你 `#include` 的库里。`printf` 这个函数的定义已经在 ｀stdio.h` 里面定义好了。

再看回去我们最后第二行的 `return`, `return` 是个关键词，是为当前的函数返回某个常量表达式。在这里我们返回了一个很陌生的变量名。可那其实不是变量，那是常量。可以从我们的 `stdlib.h` 这个库里面看到它的定义。
```c
#define EXIT_SUCCESS 0
```
所以我们得知，我们使用库其实就是把库的源码包含到我们的源码里，然后给编译器编译。其中库的代码里面的都是很多函数的定义，我们做的东西只是直接使用某个函数，或是常量而已。

**函数要先声明才能调用**, 而我们调用函数的方式就直接使用该函数名，然后紧接着 `()`就能调用了。
## main 程序入口

`main` 是个函数。而函数是这样声明的：你能看到我们的 `main` 函数就是这样的结构：

```text
返回类型 函数名(...参数) { 内容 }
```

如果*参数*，也就是括号内没有包含内容的话，那就是没有接受参数。
  
> 你能够任意取函数名，但是 `main` 和其他的函数不一样。它是程序入口 (entry), 计算机会在这里开始运行你的程序。所以每个程序都有一个 `main` 函数。

## 注释
注释不被我们的编译器读取，所以可以放心地放在源码的各个角落。注释主要是给程序员阅读的，所以写得一手好注释也是一门学问  **:D**

注释有两种方式:

```c
/* 这是多行注释 要有多长就多长 然后用 */ 结束注释

// 这是单行注释
```

好了我们对整个程序有大体认识了。我们再来看看 `main` 函数的内容。

# 表达式
表达式的结束一定是以 `;` 来表示。我们会推荐程序员一行一个表达式，而且强调缩进的重要性。因为这样能够增加源码的美观，甚至能够减少错误的发生。

<div class="tip">
  由于 C 语言的语言设计，所以编译器很难处理缺省了 `;` 的错误。所以如果你犯了如此低级的错误，少打了一个 `;`, 编译器会输出奇葩的错误讯息。但是现在的 clang 的错误讯息有所改善了，所以不用害怕这些，写就对了。
</div>


# 条件流
随着程序的复杂程度，我们需要处理条件等非线性的步骤，我们就需要用到条件控制的指令了。

## If-Then-Else
在 C 语言里面语法如下：
```c
if (condition)
  statement
else
  statement
```
`if` 接着的是被括号包裹着的 **condition**, 如果 **condition** 里面的值是布林值的 "是" (true), 或者他是非 `0` 的值，那么他就会执行紧接着的表达式。

如果你有声明 `else`， 那么 **condition** 里面遇到 `0` 或是 "非" (false) 的话，`else` 紧接着的表达式就会被执行。

如果你要执行的表达式不止一个，那么就要用 `{}` 标示语句块。例如：

```c
if (condition) {
  statement1;
  statement2;
} else {
  statement3;
  statement4;
}
```

<div class="tip">
  良心建议每个 `if` 语句都要用 `{}` 语句块。原因是，我们很难肉眼去分析我们的 `if` 到底包涵什么语句。
  ```c
  if (condition)
    statement1;
    statement2; // 这个不在 if 里面。
  ```
  而有了这个我们很清楚知道 `if` 到底包涵什么语句。
  ```c
  if (condition) {
    statement1;
  }
  statement2;
  ```
</div>

## Switch 条件分支
当我们有很多分支的时候，我们有可能会嵌套 `if-else`。但是 C 语言提供了 `switch` 功能来提高代码的可阅读性和美观！`switch` 语句的一般形式如下：

```c
switch(表达式) {
  case 常量表达式: 语句
  default: 语句
}
```
在 C 语言里面，`switch` 里的 `case` 后面的常量表达式就是用来匹配 `switch` 语句紧接着的表达式，如果匹配成功的时候被选中的 `case` 后面的语句就会被执行。

如果有 `default` 在 `switch` 语句块里面的话，那么没有任何 `case` 匹配的话就会执行 `default` 后面的语句; 如果没有 `default` 语句，而且没有任何 `case` 匹配，那整条 `switch` 语句什么都没有被执行。

`break` 语句就是用来中止这个 `switch` 语句块，并从当前语句块跳出。

> 那么很复杂的连锁 `if-else` 就能够用 `switch` 简化
```c
if (condition == "a") {
  statement1;
} else if (condition == "b") {
  statement2;
} else if (condition3 == "c") {
  statement3;
} else {
  last_statement;
}
```
>使用用 `switch` 改写成：
```c
switch (condition) {
  case "a":
    statement1;
    break;
  case "b":
    statement2;
    break;
  case "c":
    statement3;
    break;
  default:
    last_statement;
}
```

`switch` 语句对于 `case` 的顺序是任意的，但习惯上我们都会把 `default` 放到最后。
<div class="tip">
  值得一说的是，`switch` 语句的每个 `case` 标签后面的语句执行后不会自动跳出 `switch` 语句块。而是依次执行后面的所有 `case` 的语句，直到跑完为止，或是遇到 `break` 语句。

  ```c
  int number = 3;
  switch (number) {
    case 1: printf(" %d ", number);
    case 3: printf(" %d ", number);
    case 2: printf(" %d ", number);      
    default: printf(" This is default \n");
  }
  ```

  这样会打印出 `3 3 This is default`, 原因是匹配到 `case 3` 的时候，程序会执行 `case` 为 3 的语句，然后接下去执行 `case` 为 2 的语句，然后执行 `default` 的语句。
  这种情况我们称之为 "**fall through**"。当然！某种情况下确实很有用，但是在大多数情况都不被鼓励使用。
</div>

## While/Do-While 循环
当我们要重复执行一系列的语句块的时候，我们就会需要到循环，这就是 `while` 的用途。
```c
while (condition)
  statement
```
只有当 **condition** 是 "是“ (true), 或者是非 `0` 的值，那么他就会执行紧接着的表达式。一直循环执行直到 **condition** 为 "非" 或 `0` 为止。

当然你也能表达多个表达式。
```c
while (condition) {
  statement1;
  statement2;
}
```

当我们来到 `while` 语句块的时候，程序会检查 `while` 紧接着的 **condition**, 如果 **condition** 为 "非“ 或 `0`，那么里面的语句块也不会被执行。如果你想要里面的语句块至少被执行一次，可以用 `do-while`
```c
do {
  statement1;
  statement2;
} while (condition)
```
以上的 `do-while` 语句，里面的表达式会被执行，然后才会检查 `while` 紧接着的 **condition**。所以 `do-while` 的语句块至少会被执行一次。

>这可以引申到一个技巧上。当我们有个很复杂的程序的时候我们需要提早返回 (Early return)。而我们不用 `return` 语句的时候, 我们用 `break` 来中止这个循环
```c
 do {
   if (condition1) {
     break;
   }

   if (condition2) {
     break;
   }

 } while (0)
```

## For 循环
当我们要循环的时候，我们需要到控制循环的次数的时候，就会发现到 `while` 并不会给我们这一类的选项。我们需要更多的控制，用 `for`。

`for` 的定义有点复杂，我们这样写：
```c
for (int i = 0; i < 5; i++) {
  statement;
}
```

`for` 循环和其他循环的写法一样，唯一不一样的地方是括号里面复杂了许多。括号里有三个部分，第一个部分是：

`int i = 0`

只会执行一次，所以我们定一个变量为 **i**, 值为 **0**。第二个部分我们是条件：

`i < 5`

每次循环我们都会验证这个语句一次。如果其为 “真” 或非 `0` 的值就会执行 `for` 的语句块。

`i++`

第三个就是我们增值。每次的循环都会被执行一次。我们用它来对第一个部分的变量增值。`i++` 的意思就是说，我们对变量 `i` 加 1。

以上这个循环会执行五次。当然你能够在 `for` 括号任何一个部分里面放任何表达式。

> 以上循环五次的 `for` 循环也能够通过 `while` 来实现。所以对于 `for` 和 `while` 之间的选择没有什么好纠结的。
```c
int i = 0;
while (i < 5) {
  statement;
  i++;
}
```

> `for` 就是个比较紧凑的循环，把 **counter**, 条件验证， **counter** 自增这三个放进了一个语句里。

# 值操作
这下我们有基础的条件分支知识铺垫了，我们就来看看值和值之间的关系，还有如何操作值，制造命题。

## 变量
我们之前在 `for` 循环里面用的 **counter**, **i** 就是个变量。**变量可以视作一个装着值的容器，存放在内存的某个地方，而留下名字，变量名就是那个容器的名字**。而变量会带有类型。像在我们之前写的 `int i = 0;` 那就是表示我们定义一个整数类型 (**int**eger) 的变量 **i**，并将它赋值 **0**。 

嗯…… 很复杂对吧？相信我，我们之后会详谈这个变量的特殊情况。我们要知道的是到头来，所有的东西都是直接映射到内存的。

而类型，其实也就是**向 C 语言编译器表示我们这个变量，的值，会以什么方式来存储在内存里。**

```c
int a;
int b, c, i = 0;
int d = 1, e = 2, f = 3;
```

C 语言的类型前缀，写在变量名前面，如果要同时定义多个变量，用逗号 `,` 分割。

变量的赋值也很简单。只要用等号 `=`， 然后把变量名放在左边就行了，要赋予的值放在右边。

```c
// 变量的声明 (declaration)
int a, b, c;
// 变量的赋值 (assignment)
a = 123;
b = 110;
c = a + b; 
```

<div class="tip">
  老练 C 语言程序员会告诉你，不要定义未赋值的变量。
</div>

## 操作符
简单，且直观。

| 操作 | 操作符 | 例子 |
|:---:|:-----:|:----:|
| 加法  | `+` |  a + 5 |
| 减法 | `-` | a - 5 |
| 乘法 | `*` | a * 5 |
| 除法 | `/` | a / 5 |
| 模 | `%`  | a % 5 |

除此之外，C 语言也提供了一些简写，例如加法。`a += 5` 和 `a = a + 5` 等义。

| 简写 | 操作符 | 例子 |
|:---:|:-----:|:----:|
| a = a + 5  | `+＝` |  a +＝ 5 |
| a = a - 5  | `-＝` | a -＝ 5 |
| a = a * 5  | `*＝` | a *＝ 5 |
| a = a / 5  | `/＝` | a /＝ 5 |

还有一个那就是 **自递增**，和 **自递减**。例如`a++` 与 `a = a + 1` 等义。

| 展开 | 操作符 |
|:---:|:-----:|
| a = a + 1  | `a+＋` 或 `++a` |
| a = a - 1  | `a--` 或 `--a`  |

> 聪明的读者会问, **那么 a++ 和 ++a 有分别吗？**

> 其实 a++ 和 ++a 的区别很模糊，我们说 a++ 是当读取了 a 之后自增 1, 而 ++a 就是在读取 a 之前自增 1。这个要在特定情况才会有所区别。给个例子。
```c
int i = 0, j = 1;
j *= ++i;
printf("j is: %d, i is: %d\n", j, i); // 打印 j 和 i 的值
```
>和
```c
int i = 0, j = 1;
j *= i++;
printf("j is: %d, i is: %d\n", j, i); // 打印 j 和 i 的值
```
> 得到的结果分别是：
> 前者的 **j** 为 1, 后者的 **j** 为 0, 两个例子的 **i** 都是 1。

> 因为如果我们展开来看，我们的第一个例子会是
```c
int i = 0, j = 1;

i = i + 1;
j *= i; // 这时候 i 是 1
printf("j is: %d, i is: %d\n", j, i); // 打印 j 和 i 的值
```

>第二个例子会是：
```c
int i = 0, j = 1;
j *= i; // 这时候 i 还是 0
i = i + 1;
printf("j is: %d, i is: %d\n", j, i); // 打印 j 和 i 的值
```

> 顺序很重要对吧？

## 比较
所幸的是，比较符号很直观。

| 比较 | 比较符 | 例子 |
|:---:|:-----:|:----:|
| 大于  | `>` |  a > 5 |
| 小于 | `<` | a < 5 |
| 大于等于 | `>=` | a >= 5 |
| 小于等于 | `<=` | a <= b |
| 等于 | `==`  | a == b |
| 不等于 | `!=` | a != b |

## 条件
我们用 `||` 来表示 “或” (or) 操作, 用 `&&` 表示 “与” (and) 操作，用 `!` 来转义 (not)。然后用括号包裹起来，可以组成一个很长的条件。

```c
if ((sleepy) && bed_is_around && !light_is_on) {
  go_sleep;
}
```

>布林类型的值是蛮新颖的标准，所以布林类型只会于库的形式来发布，而不是 C 语言固有的标准。你需要引用 `stdbool.h` 库才行。
```c
#include <stdbool.h>
bool T = true;

if (T) {
  ...
}
```

<div class="tip">
条件式里面，任何一个非零的值都被当作 "是"  (true), 而只有 0，和 `false` 才被当作 “非” (false)
而我们鼓励你不要比较 `=` 这几个值，如 `true`, `false`, 或 `0`。
因为这很容易混淆你的代码 (除非你的意图如此……)
```c
if (a != false) == true) {
  ...
}
```
</div>

# 函数的定义
函数的定义就是这个函数要做的东西。我们用 `{}` 表示块。而在块里面的任何变量定义都是局限在这个块里面。我们称之为**作用域** (**scope**)。举个例子：

```c
int sum(int x, y) {
  int i = 233;
  return x + y;
}
  
int main() {
  sum(2, 3);
  printf("%d", i); // 变量 i 未声明
}
```
这个时候会报错，因为变量 i 是在函数 **sum()** 里声明和定义的。离开了 **sum()** 的语句块，编译器就不再 **sum()** 里的处理变量 **i**。

我们如果修改我们的代码。将变量 **i** 的声明写在 **main()** 函数里。试试看编译：

```c
int sum(int x, y) {
  int i = 233;
  return x + y;
}
  
int main() {
  int i = 100;
  sum(2, 3);
  printf("%d", i);
}
```

这个时候会打印 `100`，而不是 `233`。因为在 **sum()** 里的 **i** 和 **main()** 里的 **i** 分别在内存不同位置。而刚好变量名相同而已。

> 而我们传入函数中的参数也是同样的道理。传入函数中的参数，其实就是在表达块里面声明并定义了自己的变量，供函数的语句块使用，和传入函数的参数其实是不同位置，相等于复制了一份到函数语句块 `{}` 里一样。我们称这个为 **Call-By-Value**

不是每个函数都需要用到 `return`，但是如果一个函数没有 `return` 一个值。通常，在默认的情况下函数本身在执行完毕会自动返回 `0`，代表此函数执行完毕没有任何错误发生，而当出现错误的时候返回的数值是 `1`, `2`, `3` 之类的话。就要去翻查该函数的手册，因为这些返回的值都是有意义的。

注意到我们用的例子，`return EXIT_SUCCESS` 吗？ `EXIT_SUCCESS` 其实就是 `0` 的常量。**main()** 函数返回 `0` 就会告知我们这个程序的 **caller**，我们的程序执行完毕，而且没有任何错误。

> **main()** 函数的 **caller** 听起来很像很陌生。这就要说起函数的调用方式了。就像 **sum()** 函数那样，如果我们在 **main()** 函数里面使用了 **sum()** 函数，我们也就是从 **main()** 函数调用了它，**main()** 函数就是 **sum()** 函数的 **caller**, 而程序也会从 **main()** 跳到 **sum()** 函数的语句块里面依次执行语句，直到结束为止。届时就会返回到 **caller** 那里去，继续执行 **sum()** 接下来的语句。

> 而什么是我们的程序 **main()** 的 **caller** 呢？那就是**作业系统和你的 shell 了。**

函数本身就是用来简化代码，把代码根据功能划分成组件，留下函数名，以后使用起来调用函数名就好了。所以函数名要很清楚地表达这个函数的意义。函数就像个黑箱那样，我们不需要理会里面如何实现，只需要知道它会做什么，接受什么，返回什么，就行了。

> 这里有个黑历史。

> 在很久以前，C 语言成立了 ISO 委员会来制定标准，叫 ANSI C 标准，而在此之前的标准叫 K&R C。在 K&R C 里面，函数的声明其实和现在差很远。我们的 **sum()** 函数写作如此：
```c
sum (x, y)
    int x, y;
{
  return x + y;
}
```
> 函数头没有标示返回的类型，而且函数头带分号，紧接着是语句块。

> 什么情况开始改变呢？这就要从 **C++** 编程语言开始起了。首先 **C++** 编译器能够在编译期间检查我们的函数的声明和返回类型，以确保所有的声明都是已知，方便编译器侦查错误。所以 ANSI C 引入了这点，所以我们才可以写作：
```c
int sum (int x, y) {
  return x + y;
}
```
> 然后我们把函数的定义变成了不是表达式，而是一个复合语句，变得更容易理解了。

> 起初这样的目的是要提前对函数声明参数类型和返回类型的时候，这个情况称为前向声明 (**forward declaration**)。允许我们声明函数 (而不是定义！) 为：
```c
int sum (int x, y);
```
>甚至我们还能够缺省参数名，直接写：
```c
int sum (int, int);
```
> 我们称之为函数原型 **prototype**，我们也可以称之为 "**函数签名**" **function signature**，习惯上我们都会写在文件的前面，这样函数就能够写在任何地方了，因为编译器在依序阅读源码的时候，读到原型的时候，就知道会有个这样的函数在此文件里了，不会报出警告出来。但是现在的编译器已经很智能了，有没有原型都能成功编译成功，不报警告，而是提出提示而已。但是这样的写法一定奠定了我们现在 C 语言的写法了。

目前为止我快速地介绍了 C 语言，并对函数和变量做了个开头，下一篇我们会详细探讨变量的真正定义。到时候就会谈谈 C 语言的各种魔法了。